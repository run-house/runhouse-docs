{"embedded": false, "project": "Runhouse", "release": "0.0.2", "version": "", "last_updated": null, "copyright": "2023, Runhouse Inc", "master_doc": "index", "root_doc": "index", "use_opensearch": "", "docstitle": "Runhouse", "shorttitle": "Runhouse", "show_copyright": true, "show_search_summary": true, "show_sphinx": true, "has_source": true, "show_source": false, "sourcelink_suffix": ".txt", "file_suffix": ".fjson", "link_suffix": ".html", "script_files": ["_static/documentation_options.js", "_static/jquery.js", "_static/underscore.js", "_static/_sphinx_javascript_frameworks_compat.js", "_static/doctools.js", "_static/clipboard.min.js", "_static/copybutton.js", "_static/sphinx-book-theme.9d8b4a8b9bb19db25eeaddc40d639ba2.js", "None", "_static/sphinx-thebe.js"], "language": "en", "css_files": ["_static/pygments.css", "_static/sphinx-book-theme.css?digest=84ace793992934648b4de8eed757e5a2", "_static/sphinx-thebe.css", "_static/copybutton.css"], "sphinx_version": "5.0.2", "sphinx_version_tuple": [5, 0, 2, "final", 0], "docutils_version_info": [0, 18, 1, "final", 0], "style": "sphinx-book-theme.css?digest=84ace793992934648b4de8eed757e5a2", "rellinks": [["genindex", "General Index", "I", "index"]], "builder": "json", "parents": [], "logo": "rh_1.png", "favicon": "favicon.ico", "html5_doctype": true, "theme_nosidebar": "false", "theme_sidebarwidth": "270", "theme_body_min_width": "360", "theme_body_max_width": "800", "theme_navigation_with_keys": "True", "theme_enable_search_shortcuts": "True", "theme_globaltoc_collapse": "true", "theme_globaltoc_includehidden": "false", "theme_globaltoc_maxdepth": "", "theme_sidebar_includehidden": "True", "theme_use_edit_page_button": false, "theme_external_links": "", "theme_logo_link": "", "theme_bitbucket_url": "", "theme_github_url": "", "theme_gitlab_url": "", "theme_twitter_url": "", "theme_icon_links_label": "Icon Links", "theme_icon_links": "", "theme_google_analytics_id": "", "theme_favicons": "", "theme_show_prev_next": "True", "theme_search_bar_text": "Search the docs ...", "theme_search_bar_position": "sidebar", "theme_collapse_navigation": "False", "theme_navigation_depth": "4", "theme_show_toc_level": "1", "theme_navbar_align": "content", "theme_navbar_start": "navbar-logo.html", "theme_navbar_center": "navbar-nav.html", "theme_navbar_end": "navbar-icon-links.html", "theme_footer_items": "copyright.html, sphinx-version.html", "theme_page_sidebar_items": "page-toc.html, edit-this-page.html", "theme_single_page": "False", "theme_expand_toc_sections": "[]", "theme_path_to_docs": "docs/", "theme_repository_url": "https://github.com/run-house/runhouse", "theme_repository_branch": "main", "theme_launch_buttons": "{}", "theme_home_page_in_toc": true, "theme_logo_only": true, "theme_navbar_footer_text": "", "theme_extra_navbar": "Theme by the <a href=\"https://ebp.jupyterbook.org\">Executable Book Project</a>", "theme_extra_footer": "", "theme_use_issues_button": true, "theme_use_download_button": true, "theme_use_fullscreen_button": "True", "theme_use_repository_button": true, "theme_theme_dev_mode": "False", "theme_show_navbar_depth": "1", "theme_toc_title": "Contents", "copybutton_prompt_text": "", "copybutton_prompt_is_regexp": false, "copybutton_only_copy_prompt_lines": true, "copybutton_remove_prompts": true, "copybutton_copy_empty_lines": true, "copybutton_line_continuation_character": "", "copybutton_here_doc_delimiter": "", "copybutton_image_svg": "", "copybutton_selector": "div.highlight pre", "copybutton_format_func": "function escapeRegExp(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Removes excluded text from a Node.\n *\n * @param {Node} target Node to filter.\n * @param {string} exclude CSS selector of nodes to exclude.\n * @returns {DOMString} Text from `target` with text removed.\n */\nfunction filterText(target, exclude) {\n    const clone = target.cloneNode(true);  // clone as to not modify the live DOM\n    if (exclude) {\n        // remove excluded nodes\n        clone.querySelectorAll(exclude).forEach(node => node.remove());\n    }\n    return clone.innerText;\n}\n\n// Callback when a copy button is clicked. Will be passed the node that was clicked\n// should then grab the text and replace pieces of text that shouldn't be used in output\nfunction formatCopyText(textContent, copybuttonPromptText, isRegexp = false, onlyCopyPromptLines = true, removePrompts = true, copyEmptyLines = true, lineContinuationChar = \"\", hereDocDelim = \"\") {\n    var regexp;\n    var match;\n\n    // Do we check for line continuation characters and \"HERE-documents\"?\n    var useLineCont = !!lineContinuationChar\n    var useHereDoc = !!hereDocDelim\n\n    // create regexp to capture prompt and remaining line\n    if (isRegexp) {\n        regexp = new RegExp('^(' + copybuttonPromptText + ')(.*)')\n    } else {\n        regexp = new RegExp('^(' + escapeRegExp(copybuttonPromptText) + ')(.*)')\n    }\n\n    const outputLines = [];\n    var promptFound = false;\n    var gotLineCont = false;\n    var gotHereDoc = false;\n    const lineGotPrompt = [];\n    for (const line of textContent.split('\\n')) {\n        match = line.match(regexp)\n        if (match || gotLineCont || gotHereDoc) {\n            promptFound = regexp.test(line)\n            lineGotPrompt.push(promptFound)\n            if (removePrompts && promptFound) {\n                outputLines.push(match[2])\n            } else {\n                outputLines.push(line)\n            }\n            gotLineCont = line.endsWith(lineContinuationChar) & useLineCont\n            if (line.includes(hereDocDelim) & useHereDoc)\n                gotHereDoc = !gotHereDoc\n        } else if (!onlyCopyPromptLines) {\n            outputLines.push(line)\n        } else if (copyEmptyLines && line.trim() === '') {\n            outputLines.push(line)\n        }\n    }\n\n    // If no lines with the prompt were found then just use original lines\n    if (lineGotPrompt.some(v => v === true)) {\n        textContent = outputLines.join('\\n');\n    }\n\n    // Remove a trailing newline to avoid auto-running when pasting\n    if (textContent.endsWith(\"\\n\")) {\n        textContent = textContent.slice(0, -1)\n    }\n    return textContent\n}\n", "copybutton_exclude": ".linenos, .gp"}