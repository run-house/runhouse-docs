Cloud Quick Start
=================

.. raw:: html

    <p><a href="https://colab.research.google.com/github/run-house/notebooks/blob/stable/docs/quick-start-cloud.ipynb">
    <img height="20px" width="117px" src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a></p>

Runhouse lets you quickly and easily deploy your Python code to any remote infra, as if it were attached to your laptop.

This tutorial demonstrates how to

-  Connect to an existing remote IP, fresh cloud VM, or Kubernetes pod in Python.
-  Send a locally defined function onto the remote compute and call it as a service.

Installing Runhouse
-------------------

The Runhouse base package can be installed with:

.. code:: ipython3

    !pip install runhouse

To use Runhouse to launch on-demand clusters, please instead run the
following command. This additionally installs
`SkyPilot <https://github.com/skypilot-org/skypilot>`__, which is used
for launching fresh VMs through your cloud provider.

.. code:: ipython3

    !pip install "runhouse[sky]"

Local Python Function
---------------------

First, let‚Äôs define the function that we want to be run on our remote
compute. This is just a regular Python function; no decorators,
wrappers, or configs are necessary.

.. code:: ipython3

    def get_pid(a = 0):
        import os
        return os.getpid()

Runhouse Cluster
----------------

In Runhouse, a ‚Äúcluster‚Äù is a unit of compute, somewhere you can send
code, data, or requests to execute. We define a Runhouse cluster using
the ``rh.cluster`` factory function.

This requires having access to existing compute via SSH, a cloud provider account, or a Kubernetes cluster
(.kube/config). If you do not have access to a cluster, you can try the `local
version <https://www.run.house/docs/tutorials/quick-start-local>`__ of this
tutorial, which sets up and deploys the Python function to a local
server, rather than a remote cluster.

To use a cluster that‚Äôs already running:

.. code:: ipython3

    cluster = rh.cluster(
        name="rh-cluster",
        host="example-cluster",  # hostname or ip address,
        ssh_creds={"ssh_user": "ubuntu", "ssh_private_key": "~/.ssh/id_rsa"},  # credentials for ssh-ing into the cluster
    )

If you do not have a cluster up, but have cloud credentials (e.g.¬†aws,
gcp, azure) for launching clusters or a Kubernetes cluster, you can set
up and launch an on-demand cluster with ``rh.ondemand_cluster``. This uses SkyPilot under
the hood, so run ``sky check`` in a CLI first to make sure credentials are set up properly.

.. code:: ipython3

    cluster = rh.ondemand_cluster(
        name="rh-cluster",
        instance_type="CPU:2+",
        provider="aws"
    )
    cluster.up_if_not()

    # terminate this cluster with `cluster.teardown()` in Python, or `sky down rh-cluster` in CLI

There are a number of options to specify the resources more finely, such as GPUs (``instance_type="A10G:4"``),
cloud provider names (``instance_type="m5.xlarge"``), ``num_instances=n`` for multiple instances,
``memory``, ``disk_size``, ``region``, ``image_id``, ``open_ports``, ``spot``, and more. See the
`on_demand_cluster docs <https://www.run.house/docs/api/python/cluster#runhouse.ondemand_cluster>`__.
You can also omit the provider argument to allocate from the cheapest available source for which you
have credentials.

Deployment
----------

Simply wrap the function in ``rh.function`` and send it to the
cluster with ``.to``. This actually deploys the function to the cluster as a
proper service by syncing over the code, setting up any specified
dependencies (see ``Envs``), and importing and serving it in the Runhouse API server.
We're connected via an SSH tunnel here, so the service is secure, but we can also open ports
and secure it with Runhouse's out-of-the-box authentication and HTTPS.

Classes, or ``Modules`` are also supported, opening up a world of possibilities
through persistent state. ``Envs`` allow you to specify the environment in which the
function or class is served, such as dependencies, environment variables, secrets,
conda environments, and more, and allow you to easily achieve powerful parallelism across the cluster.
These are covered in more detail in the API tutorials.

.. code:: ipython3

    remote_fn = rh.function(get_pid).to(cluster)


.. parsed-literal::
    :class: code-output

    INFO | 2024-02-26 21:01:50.579156 | Because this function is defined in a notebook, writing it out to a file to make it importable. Please make sure the function does not rely on any local variables, including imports (which should be moved inside the function body). Functions defined in Python files can be used normally.
    INFO | 2024-02-26 21:01:50.584346 | Copying package from file:///Users/caroline/Documents/runhouse/notebooks to: rh-cluster
    INFO | 2024-02-26 21:01:54.745264 | Calling base_env.install


.. parsed-literal::
    :class: code-output

    [36mInstalling Package: notebooks with method reqs.
    [0m[36mreqs path: notebooks/requirements.txt
    [0m[36mnotebooks/requirements.txt not found, skipping
    [0m

.. parsed-literal::
    :class: code-output

    INFO | 2024-02-26 21:01:56.116714 | Time to call base_env.install: 1.37 seconds
    INFO | 2024-02-26 21:02:04.892297 | Sending module get_pid to rh-cluster



.. raw:: html

    <pre style="white-space:pre;overflow-x:auto;line-height:normal;font-family:Menlo,'DejaVu Sans Mono',consolas,'Courier New',monospace">
    </pre>



The function we defined above, ``get_pid``, now exists remotely on the
cluster, and can be called remotely using ``remote_fn``. You can call
this remote function just as you would any other Python function, with
``remote_fn()``, and it runs on the cluster and returns the result to
our local environment.

Below, we run both the local and remote versions of this function, which
give different results and confirms that the functions are indeed being
run on different processes.

.. code:: ipython3

    print(f"Local PID {get_pid()}")
    print(f"Remote PID {remote_fn()}")


.. parsed-literal::
    :class: code-output

    INFO | 2024-02-26 21:02:43.117612 | Calling get_pid.call
    INFO | 2024-02-26 21:02:44.228964 | Time to call get_pid.call: 1.11 seconds




.. parsed-literal::
    :class: code-output

    Local PID 27818
    Remote PID 33366




If you launched an on-demand cluster, you can terminate it by calling
``cluster.teardown()``.

.. code:: ipython3

    cluster.teardown()

Dive Deeper
-----------

What we just did, running a locally defined function on remote compute,
is just the tip of the iceberg of what‚Äôs possible with Runhouse. With a
large suite of even more abstractions and features, Runhouse lets you
quickly and seamlessly integrate between local and remote environments.

To learn more, please take a look at our other tutorials, or at the `API
reference <https://www.run.house/docs/api/python>`__
